<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Diana Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="writing_schemas.html"><strong aria-hidden="true">3.</strong> Writing Schemas</a></li><li class="chapter-item expanded "><a href="config.html"><strong aria-hidden="true">4.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="auth.html"><strong aria-hidden="true">5.</strong> Authentication</a></li><li class="chapter-item expanded "><a href="serverless.html"><strong aria-hidden="true">6.</strong> Going Serverless</a></li><li class="chapter-item expanded "><a href="core/getting_started.html"><strong aria-hidden="true">7.</strong> Core Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core/queries_mutations.html"><strong aria-hidden="true">7.1.</strong> Handling Queries and Mutations</a></li><li class="chapter-item expanded "><a href="core/auth.html"><strong aria-hidden="true">7.2.</strong> Authentication</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Diana Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/diana-graphql/diana">Diana</a> â€¢ <a href="https://crates.io/crates/diana">Crate Page</a> â€¢ <a href="https://docs.rs/diana">API Documentation</a> â€¢ <a href="./CONTRIBUTING.html">Contributing</a></p>
<p>Welcome to the Diana book, the central location for all Diana documentation! This is designed to be read in order, but each page should also be self-containing for later reference. If you find an issue with this documentation or you'd like to contribute in any way to the project, please <a href="https://github.com/diana-graphql/diana/issues/new/choose">open an issue</a> and let us know!</p>
<p>If you're looking for a more general overview of the project, please see the <a href="https://github.com/diana-graphql/diana">README</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Diana is a high-level wrapper around <a href="https://crates.io/crates/async-graphql">async_graphql</a>, and is designed to be as easy as possible to get started with! This page is a basic tutorial of how to get started with a full and working setup.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Assuming you have Rust already installed (if not, <a href="https://www.rust-lang.org/tools/install">here's</a> a guide on how to do so), you can add Diana as a dependency to your project easily by adding the following to your project's <code>Cargo.toml</code> under <code>[dependencies]</code>:</p>
<pre><code>diana = &quot;0.2.3&quot;
</code></pre>
<p>Now run <code>cargo build</code> to download all dependencies. Diana is large and complex, so this will take quite a while!</p>
<p>If you're new to GraphQL, we highly recommend reading more about it before diving further into Diana. You can see more about it on the <a href="https://graphql.org">official GraphQL website</a>.</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>We recommend a specific project structure for new projects using Diana, but it's entirely optional! It is however designed to minimize code duplication and maximize efficiency by allowing you to run both the queries/mutations system and the subscriptions server simultaneously.</p>
<p>Critically, we recommend having three binary crates for your two servers and the serverless function, as well as a library crate for your schemas and configurations. These should all be Cargo workspaces.</p>
<pre><code>lib/
	src/
		lib.rs
	Cargo.toml
server/
	src/
		main.rs
	Cargo.toml
serverless/
	src/
		main.rs
	Cargo.toml
subscriptions/
	src/
		main.rs
	Cargo.toml
Cargo.lock
Cargo.toml
</code></pre>
<p>Set this up for now if possible, and we'll add to it later across the book (it will be assumed that you're using this or something similar).</p>
<p>You should also have the following in your root <code>Cargo.toml</code> to set up workspaces (which you can read more about <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">here</a>):</p>
<pre><code class="language-toml">[workspace]

members = [
	&quot;lib&quot;,
    &quot;server&quot;,
    &quot;serverless&quot;,
	&quot;subscriptions&quot;
]
</code></pre>
<p>Then you can make all the binary crates (everything except <code>lib</code>) dependent on your shared logic by adding this to the <code>Cargo.toml</code> files in <code>server</code>, <code>serverless</code>, and <code>subscriptions</code> under <code>[dependencies]</code>:</p>
<pre><code class="language-toml">lib = { path = &quot;../lib&quot; }
</code></pre>
<p>You can then reference <code>lib</code> in those crates as if it were just another external module!</p>
<h2 id="your-first-schema"><a class="header" href="#your-first-schema">Your first schema</a></h2>
<p>If you're familiar with GraphQL, then the first thing you'll need to do to set up Diana is to write a basic schema. Diana depends entirely on <a href="https://crates.io/crates/async-graphql">async_graphql</a> for this, so <a href="https://async-graphql.github.io">their documentation</a> may also help you (particularly in more advanced cases), though this book should be enough for the simple stuff.</p>
<p>Your first schema can be really simple, we'll just make a simple query that reports the API version when queried (we won't add any mutations or subscriptions for now). Try adding this somewhere in your shared logic:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diana::{
	async_graphql::{
		Object as GQLObject
	}
}

#[derive(Default, Clone)]
pub struct Query {}
#[GQLObject]
impl Query {
    async fn api_version(&amp;self) -&gt; &amp;str {
        &quot;0.1.0&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is probably the simplest schema you'll ever create! Crucially though, you MUST derive the <code>Default</code> and <code>Clone</code> traits on it. The former is required by <code>async_graphql</code>, and the latter for Diana.</p>
<p>Hopefully you can see that our <code>Query</code> object is simply defining one query, <code>api_version</code>, which just returns <code>0.1.0</code>, the version of our API! Conveniently, <code>async_graphql</code> automatically parses this into the more conventional <code>apiVersion</code> when we call this, so you can conform to Rust and GraphQL conventions at the same time!</p>
<h2 id="your-first-options"><a class="header" href="#your-first-options">Your first options</a></h2>
<p>Every part of Diana is configured using the <code>Options</code> struct, which can be created with <code>OptionsBuilder</code>. For now, we'll set up a simple configuration without any subscriptions support. Add this to your shared logic:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diana::{Options, OptionsBuilder, AuthBlockState};
use diana::async_graphql::{EmptyMutation, EmptySubscription};
use crate::Query; // Or wherever you put your `Query` object from the previous section

#[derive(Clone)]
pub struct Context(String);

pub fn get_opts() -&gt; Options&lt;Context, Query, EmptyMutation, EmptySubscription&gt; {
    OptionsBuilder::new()
        .ctx(Context(&quot;test&quot;.to_string()))
        .auth_block_state(AuthBlockLevel::AllowAll)
        .jwt_secret(&quot;this is a secret&quot;)
        .schema(Query {}, Mutation {}, Subscription {})
        .finish()
        .expect(&quot;Failed to build options!&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice that we define a <code>Context</code> struct here. This will get passed around to every GraphQL resolver and you'll always be able to access it. As long as it's <code>Clone</code>able, you can put anything in here safely. A common use-case of this in reality would be as a database connection pool. Here, we just define it with a random string inside.</p>
<p>Next, we define a function <code>get_opts()</code> that initializes our <code>Options</code>. We set the context, define our schema, and do two other things that need some explaining. The first is <code>.auth_block_state()</code>, which sets the required authentication level to access our GraphQL endpoint. Diana has authentication built-in, so this is fundamental. Here, we allow anything, authenticated or not, for educational purposes. In a production app, set this to block everything! You can read more about authentication <a href="./auth.html">here</a>. The second thing that needs explaining is <code>.jwt_secret()</code>. Diana's authentication systems is based on JWTs, which are basically tokens that clients send to servers to prove their identity (the server signed them earlier, and so can verify them). JWTs need a secret to be based on, and we define a very silly one here. In a production app, you should read this from an environment variable and it should be randomly generated (more on that <a href="./auth.html">here</a>).</p>
<h2 id="your-first-server"><a class="header" href="#your-first-server">Your first server</a></h2>
<p>Let's try plugging this into a basic Diana server! Diana is based around integrations for different platforms, and it currently supports only Actix Web for serverful systems, so that's what we'll use! You should add this to your <code>Cargo.toml</code> in the <code>server</code> crate under <code>[dependencies]</code>:</p>
<pre><code class="language-toml">diana-actix-web = &quot;0.2.3&quot;
</code></pre>
<p>Now add the following to your <code>main.rs</code> in the <code>server</code> crate:</p>
<pre><pre class="playground"><code class="language-rust">use diana_actix_web::{
    actix_web::{App, HttpServer},
    create_graphql_server,
};
use diana::async_graphql::{EmptyMutation, EmptySubscription};
use lib::{get_opts, Query}

#[diana_actix_web::actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let configurer = create_graphql_server(get_opts()).expect(&quot;Failed to set up configurer!&quot;);

    HttpServer::new(move || App::new().configure(configurer.clone()))
        .bind(&quot;0.0.0.0:9000&quot;)?
        .run()
        .await
}
</code></pre></pre>
<p>Firstly, we're pulling in the dependencies we need, including the schema and the function to get our <code>Options</code>. Then, we define an asynchronous <code>main</code> function marked as the entrypoint for <code>actix_web</code>, in which we set up our entire GraphQL server using <code>create_graphql-server()</code>, parsing in our <code>Options</code>. After that, we start up a new Actix Web server, using <code>.configure()</code> to configure the entire thing. Pretty convenient, huh?</p>
<p>If you also have some REST endpoints or the like, you can easily add them to this server as well, <code>.configure()</code> is inbuilt into Actix Web to enable this kind of modularization.</p>
<h2 id="firing-it-up"><a class="header" href="#firing-it-up">Firing it up</a></h2>
<p>The last step of all this is to actually run your server! Go into the <code>server</code> crate and run <code>cargo run</code> to see it in action! If all has gone well, you should see be able to see the GraphiQL playground (GUI for GraphQL development) in your browser at <a href="http://localhost:9000/graphiql">http://localhost:9000/graphiql</a>! Try typing in the following and then run it!</p>
<pre><code>query {
	apiVersion
}
</code></pre>
<p>You should see <code>0.1.0</code> faithfully printed on the right-hand side of the screen.</p>
<p>Congratulations! You've just set up your first GraphQL server with Diana! The rest of this book will help you to understand how to extend this setup to include mutations, subscriptions, and authentication, as well as helping you to deploy it all serverlessly!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-schemas"><a class="header" href="#writing-schemas">Writing Schemas</a></h1>
<p>The most critical part of GraphQL is schemas, and they're easily the most complex part of Diana. This page will explain how to write schemas that work with Diana, and it will explain how to get subscriptions to work properly, however it will not explain how to write basic schemas from scratch. For that, please refer to <a href="https://async-graphql.github.io">async_graphql's documentation</a>.</p>
<h2 id="subscriptions"><a class="header" href="#subscriptions">Subscriptions</a></h2>
<p>A basic Diana subscription would look something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diana::async_graphql::{Subscription as GQLSubscription, Context as GQLCtx};
use diana::errors::GQLResult;
use diana::stream;

#[derive(Default, Clone)]
pub struct Subscription;
#[GQLSubscription]
impl Subscription {
    async fn new_blahs(
        &amp;self,
        raw_ctx: &amp;GQLCtx&lt;'_&gt;,
    ) -&gt; impl Stream&lt;Item = GQLResult&lt;String&gt;&gt; {
        let stream_result = get_stream_for_channel_from_ctx(&quot;channel_name&quot;, raw_ctx);

        stream! {
            let stream = stream_result?;
            for await message in stream {
                yield Ok(message);
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>All this does is sets up a subscription that will return the strings on a particular channel. And this shows perfectly how subscriptions in Diana work -- channels. You publish something on a channel from the queries/mutations system and then receive it as above. You can then use the re-exported <code>stream!</code> macro to return a stream for it.</p>
<p>Note that if you're trying to send a struct across channels you'll need to serialize/deserialize it into/out of a string for transport. However, as subscriptions can return errors in their streams, this shouldn't be a problem!</p>
<h2 id="mutations-that-link-with-subscriptions"><a class="header" href="#mutations-that-link-with-subscriptions">Mutations that link with subscriptions</a></h2>
<p>The most common thing to trigger a subscription is some kind of mutation on the queries/mutations system, and so Diana provides a simple programmatic way of publishing data on a particular channel:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diana::async_graphql::{Subscription as GQLSubscription, Context as GQLCtx};
use diana::errors::GQLResult;
use diana::stream;
use diana::Publisher;

#[derive(Default, Clone)]
pub struct Mutation {}
#[GQLObject]
impl Mutation {
    async fn update_blah(
        &amp;self,
        raw_ctx: &amp;async_graphql::Context&lt;'_&gt;,
    ) -&gt; GQLResult&lt;bool&gt; {
        let publisher = raw_ctx.data::&lt;Publisher&gt;()?;
        publisher.publish(&quot;channel_name&quot;, &quot;important message&quot;).await?;
        Ok(true)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In the above example, we get a <code>Publisher</code> out of the GraphQL context (it's automatically injected), and we use it to easily send a message to the subscriptions server on the <code>channel_name</code> channel. Our subscription from the previous example would pick this up and stream it to the client.</p>
<h2 id="linking-other-services-to-subscriptions"><a class="header" href="#linking-other-services-to-subscriptions">Linking other services to subscriptions</a></h2>
<p>Of course, it's entirely possible that services well beyond GraphQL may need to trigger a subscription message, and so you can easily push a message from anywhere where you can execute a basic HTTP request. Diana's subscriptions server has an inbuilt mutation <code>publish</code>, which takes a channel to publish on and a string message to publish. This can be called over a simple HTTP request from anywhere. However, this endpoint requires authentication, and you must have a valid JWT signed with the secret you've provided to be able to access it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Diana is configured using the <code>Options</code> struct. This page will go through in detail what can be specified using that system. Here's an example options initialization that we'll work through:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>OptionsBuilder::new()
        .ctx(Context(&quot;test&quot;.to_string()))
        .subscriptions_server_hostname(&quot;http://localhost&quot;)
        .subscriptions_server_port(&quot;9002&quot;)
        .subscriptions_server_endpoint(&quot;/graphql&quot;)
        .jwt_to_connect_to_subscriptions_server(
            &amp;env::var(&quot;SUBSCRIPTIONS_SERVER_PUBLISH_JWT&quot;).unwrap(),
        )
        .auth_block_state(AuthBlockLevel::AllowAll)
        .jwt_secret(&amp;env::var(&quot;JWT_SECRET&quot;).unwrap())
        .schema(Query {}, Mutation {}, Subscription {})
        .graphql_endpoint(&quot;/graphql&quot;)
		.playground_endpoint(&quot;/graphiql&quot;)
        .finish()
        .expect(&quot;Failed to build options!&quot;)
<span class="boring">}
</span></code></pre></pre>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>You must provide a context struct to Diana by using the <code>.ctx()</code> function. This struct will be parsed to all resolvers, and can be trivially accessed by using this in your resolvers:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ctx = raw_ctx.data&lt;Context&gt;()?;
<span class="boring">}
</span></code></pre></pre>
<p>A common use of the context struct is for a database pool.</p>
<h2 id="subscriptions-server-configuration"><a class="header" href="#subscriptions-server-configuration">Subscriptions server configuration</a></h2>
<p>You need to provide the details of the subscriptions server in your configuration so the queries/mutation system knows where it is on the internet. This is defined using these four functions:</p>
<ul>
<li><code>.subscriptions_server_hostname()</code> -- the hostname of the subscriptions server (e.g. <code>http://localhost</code></li>
<li><code>.subscriptions_server_port()</code> -- the port the subscriptions server is running on</li>
<li><code>.subscriptions_server_endpoint()</code> -- the GraphQL endpoint to connect to on the subscriptions server (e.g. <code>/graphql</code>)</li>
<li><code>.jwt_to_connect_to_subscriptions_server()</code> -- a JWT to use to authenticate against the subscriptions server, which must be signed with the secret define by <code>.jwt_secret()</code>; this JWT must have a payload which defines <code>role: &quot;graphql_server&quot;</code> (see <a href="./auth.html">Authentication</a>)</li>
</ul>
<p>If you aren't using subscriptions at all in your setup, you don't have to use any of these functions.</p>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>Two properties define authentication data for Diana: <code>.jwt_secret()</code> and <code>.auth_block_state()</code>. The former defines the string secret to use to sign all JWTs (internally used for the communication channel between the two systems of Diana, you can use it too for authenticating clients). The latter defines the level of authentication required to connect to the GraphQL endpoint. This can be one of the following:</p>
<ul>
<li><code>AuthBlockLevel::AllowAll</code> -- allows everything, only ever use this in development unless you have an excellent reason</li>
<li><code>AuthBlockLevel::BlockUnauthenticated</code> -- blocks anything without a valid JWT</li>
<li><code>AuthBlockLevel::AllowMissing</code> -- blocks invalid tokens, but allows requests without tokens; this is designed for development use to show authentication while also allowing GraphiQL introspection (the hints and error messages like an IDE); do NOT use this in production!</li>
</ul>
<h2 id="endpoints"><a class="header" href="#endpoints">Endpoints</a></h2>
<p>The two functions <code>.graphql_endpoint()</code> and <code>.playground_endpoint</code> define the locations of your GraphQL endpoint and the endpoint for the GraphiQL playground, though you probably won't use them unless you're using something novel, they are set to <code>/graphql</code> and <code>/graphiql</code> respectively by default.</p>
<h2 id="schema"><a class="header" href="#schema">Schema</a></h2>
<p>The last function is <code>.schema()</code>, which defines the actual schema for your app. You'll need to provide your <code>Query</code>, <code>Mutation</code> and <code>Subscription</code> types here. If you're not using subscriptions, you can use <code>diana::async_graphql::EmptySubscription</code> instead. There's also an <code>EmptyMutation</code> type if you need it. At least one query is mandatory. You should initialize each of these structs for this function with this notation:</p>
<pre><code>Query {}
</code></pre>
<h2 id="building-it"><a class="header" href="#building-it">Building it</a></h2>
<p>Once you've run all those functions, you can build the <code>Options</code> by using <code>.finish()</code>, which will return a <code>Result&lt;Options, diana::errors::Error&gt;</code>. Because you can't do anything at all without the options defined properly, it's typical to run <code>.expect()</code> after this to <code>panic!</code> quickly if the configuration couldn't be built.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h1>
<p>Authentication is built into Diana out of the box using JWTs. It's designed to be as intuitive as possible, but there are a few things you should know when working with it.</p>
<blockquote>
<p>ðŸš§ Authentication is not yet supported over subscriptions, this will be added soon! ðŸš§</p>
</blockquote>
<h2 id="authentication-block-level"><a class="header" href="#authentication-block-level">Authentication Block Level</a></h2>
<p>In your configuration, you define a required level of authentication for your GraphQL endpoints using <code>.auth_block_state()</code>. The different levels are explained on <a href="./config.html">the configuration page</a>, so all that will be added now is that they apply to all GraphQL endpoints, from both the queries/mutations and the subscriptions systems. <code>BlockUnauthenticated</code> is vastly preferred and recommended in production.</p>
<h2 id="jwts"><a class="header" href="#jwts">JWTs</a></h2>
<p>Diana has full support for JWTs out of the box, and uses them internally to allow connections between its two systems. That means that you will need to create a JWT to enable this communication, which can be done using <code>diana::create_jwt</code>! Diana provides a few function for managing JWTs: <code>create_jwt</code>, <code>validate_and_decode_jwt</code>, <code>get_jwt_secret</code>, and <code>decode_time_str</code>. Those are all pretty self-explanatory except perhaps the last one, which turns strings like <code>1w</code> into one week from the present datetime in seconds after January 1st 1970 (Unix epoch), allowing you to more conveniently define JWT expiries. This is based on Vercel's <a href="https://github.com/vercel/ms">ms</a> module for JavaScript, though only implements a subset of its features.</p>
<p>The documentation for those functions is best seen directly in raw form <a href="https://docs.rs/diana">here</a>. The most important thing to know is that the JWT for connecting to the subscriptions server MUST define the <code>role</code> property in its payload to be <code>graphql_server</code>. Otherwise authentication will fail for <code>BlockUnauthenticated</code> and <code>AllowMissing</code>.</p>
<h2 id="graphiql"><a class="header" href="#graphiql">GraphiQL</a></h2>
<p>GraphiQL is currently only supported in development (it will be disabled by force in production), and so there is as yet no need for authenticating for access to it. If and when it is usable in production, this will come with an authentication system for it.</p>
<p>In development, you may need to provide a JWT that you've generated in order to test authentication. You can do this by opening the <em>Headers</em> panel at the bottom of the screen and typing the following:</p>
<pre><code class="language-json">{
	&quot;Authorization&quot;: &quot;Bearer YOUR_TOKEN_HERE&quot;
}
</code></pre>
<p>Please note that authentication is not yet supported for subscriptions, and so this will have no effect on them (equivalent to a permanent <code>AllowAll</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="going-serverless"><a class="header" href="#going-serverless">Going Serverless</a></h1>
<p>Diana's most unique feature is its ability to bridge the serverless and serverful gap all in one system, and it's about time we covered how to use the serverless system! As for serverful systems, Diana uses integrations to support different serverless platforms. Currently, the only integration is for AWS Lambda and its derivatives, like Netlify and Vercel, so that's what we'll use here!</p>
<p>Crucially, <strong>no part of your schemas or options</strong> should have to change to go serverless, it should be simply a different way of using them.</p>
<h2 id="coding-it"><a class="header" href="#coding-it">Coding it</a></h2>
<p>First off, install <code>diana-aws-lambda</code> by adding the following to your <code>Cargo.toml</code> for the <code>serverless</code> crate under <code>[dependencies]</code> (notice that versions of integrations and the core library are kept in sync deliberately):</p>
<pre><code class="language-toml">diana-aws-lambda = &quot;0.2.3&quot;
</code></pre>
<pre><pre class="playground"><code class="language-rust">use diana_aws_lambda::{
    netlify_lambda_http::{
        lambda, lambda::Context as LambdaCtx, IntoResponse as IntoLambdaResponse,
        Request as LambdaRequest,
    },
    run_aws_req, AwsError,
};
use lib::get_opts;

#[lambda(http)]
#[tokio::main]
async fn main(req: LambdaRequest, _: LambdaCtx) -&gt; Result&lt;impl IntoLambdaResponse, AwsError&gt; {
    let res = run_aws_req(req, get_opts()).await?;
    Ok(res)
}
</code></pre></pre>
<p>This example also expects you to have <a href="https://crates.io/crates/tokio">tokio</a> installed, you'll need a version above v1.0.0 for the runtime to work.</p>
<p>The serverless system is quite a bit simpler than the serverful system actually, because it just runs a query/mutation directly, without any need to run a server for a longer period. This handler is now entirely complete.</p>
<p>One thing to remember that could easily stump you for a while is environment variables. if you're reading from an environment variable file in your configuration setup, don't do that when you're in the serverless environment! And don't forget to add your environment variables to the serverless provider so they're available to your code!</p>
<h2 id="deploying-it"><a class="header" href="#deploying-it">Deploying it</a></h2>
<p>This page will only cover deploying this to <a href="https://netlify.com">Netlify</a>, since that's arguably the most convenient service to set up for Rust serverless functions quickly right now. The rest of this section will assume you have a Netlify account and that you've installed the Netlify CLI. The process is however relatively similar for other services.</p>
<p>Firstly, you'll need to set up a few basic things for Netlify deployment to work. Create a file named <code>rust-toolchain</code> in the <code>serverless</code> crate at its root (next to <code>Cargo.toml</code>). Then put the following in that file:</p>
<pre><code class="language-toml">[toolchain]
channel = &quot;stable&quot;
components = [&quot;rustfmt&quot;, &quot;clippy&quot;]
targets = [&quot;x86_64-unknown-linux-musl&quot;]
</code></pre>
<p>This tells Netlify how to prepare the environment for Rust. Next, you'll need some static files to deploy as a website (you may already have a frontend to use, otherwise just a basic <code>inde.html</code> is fine). Put these in a new directory in the <code>serverless</code> crate called <code>public</code>. Also create another new empty directory called <code>functions</code> next to it.</p>
<p>Now we'll create a basic Netlify configuration. Create a <code>netlify.toml</code> file in the root of the <code>serverless</code> crate and put the following in it:</p>
<pre><code class="language-toml">[build]
publish = &quot;public&quot;
functions = &quot;functions&quot;
</code></pre>
<p>This tells Netlify where your static files and functions are. But we haven't actually got any compiled functions yet, so we'll set those up now! Your final function will be the compiled executable of your code in <code>src/main.rs</code>.</p>
<p>Now we'll create a build script to prepare your function automatically. Create a new file in the <code>serverless</code> crate called <code>build.sh</code> and fill it with the following:</p>
<pre><code class="language-bash">#!/bin/bash

cargo build --release --target x86_64-unknown-linux-musl
cp ./target/x86_64-unknown-linux-musl/release/serverless functions
</code></pre>
<p>This will compile your binary for production and copy it to the <code>functions</code> directory, where Netlify can access it. Note that we're compiling for the <code>x86_64-unknown-linux-musl</code> target triple, which is the environment on Netlify's servers. To be able to compile for that target (a variant of Linux), you'll need to add it with <code>rustup target add x86_64-unknown-linux-musl</code>, which will download what you need.</p>
<p>There's one more thing we have to do before we can deploy though, and that's minimizing the size of the binary. Rust by default creates very large binaries, optimizing for speed instead. Diana is large and complex, which exacerbates this problem. Netlify does not like large binaries. At all. Which means we need to slim our release binary down significantly. However, because Netlify support for Rust is in beta, certain very powerful optimizations (like running <code>strip</code> to halve the size) will result in Netlify being unable to even detect your binary. Add the following to your <em>root</em> <code>Cargo.toml</code> (the one for all your crates):</p>
<pre><code class="language-toml">[profile.release]
opt-level = &quot;z&quot;
codegen-units = 1
panic = &quot;abort&quot;
</code></pre>
<p>This changes the compiler to optimize for size rather than speed, removes extra unnecessary optimization code, and removes the entire panic handling matrix. What this means is that your binary becomes smaller, which is great! However, if your program happens to <code>panic!</code> in production, it will just abort, so if you have <em>any</em> custom panic handling logic, you'll need to play around with this a bit. Netlify will generally accept binaries under 15MB. Now there are more optimizations we could apply here to make the binary tiny, but then Netlify can't even detect it, so this is the best we can do (if you have something else that works better, please <a href="https://github.com/diana-graphql/diana/issues/new">open an issue</a>).</p>
<p>Finally, you can run <code>sh build.sh</code> to build your function! Now we just need to send it to Netlify!</p>
<ol>
<li>Log in to Netlify from the terminal with <code>netlify login</code>.</li>
<li>Create a new site for this project for manual deployment with <code>netlify init --manual</code> (run this in <code>serverless</code>).</li>
<li>Deploy to production with <code>netlify deploy --prod</code>!</li>
</ol>
<p>You should now be able to query your live production GraphQL serverless function with any GraphQL or HTTP client! If you're having problems, Netlify's docunmentation may help, and don't forget to look at your site's logs!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-diana-core"><a class="header" href="#getting-started-with-diana-core">Getting Started with Diana Core</a></h1>
<p>Diana is built for use with integrations, but if you want to support a platform without an integration, you'll need to work with Diana core. This shouldn't be too daunting, as it's designed to work as well as possible with queries and mutations in particular. Subscriptions are not yet well supported in Diana Core, and we strongly advise using the <a href="https://crates.io/crates/diana-actix-web">diana-actix-web</a> integration for your subscriptions server.</p>
<p>Diana core is just the <code>diana</code> package, which you should already have installed from <a href="core/../getting_started.html">Getting Started</a>.</p>
<p>This guide is designed to be as generic as possible, and it may be useful to have some perspective on how to actually build an integration, for which you should look to the <a href="https://github.com/diana-graphql/diana/tree/main/integrations/serverful/actix-web/src">Actix Web integration</a>. That folder also contains examples of using <code>async_graphql</code> and its integrations more directly to support subscriptions (which is how you would probably do it if you were building your own integration).</p>
<p>Finally, if you build a fully-fledged integration for a serverful or serverless platform, please <a href="https://github.com/diana-graphql/diana/pulls/new">submit a pull request</a> to get it into the Diana codebase! We'd really appreciate your contribution! You can see our contributing guidelines <a href="https://github.com/diana-graphql/diana/tree/main/CONTRIBUTING.md">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-queries-and-mutations"><a class="header" href="#handling-queries-and-mutations">Handling Queries and Mutations</a></h1>
<p>The main struct you'll be dealing with here is <a href="https://docs.rs/diana/0.2.3/diana/struct.DianaHandler.html"><code>DianaHandler</code></a>, and the API documentation for Diana is your friend here.</p>
<p>You can create a new <code>DianaHandler</code> by running <code>DianaHandler::new()</code> and providing it the <code>Options</code> you're using for your setup. That will automatically create schemas internally for queries/mutation and subscriptions. The two are mutually exclusive.</p>
<h2 id="running-a-request"><a class="header" href="#running-a-request">Running a request</a></h2>
<p>There are two functions you can use for running queries and mutations: <code>.run_stateless_for_subscriptions()</code> and <code>.run_stateless_without_subscriptions()</code>. The first uses the schema for the subscriptions system, which would be used basically only for running the internally used <code>publish</code> mutation. The latter is used for running the user's queries. If you're building for an unsupported platform, you'll need to support both if you want to support subscriptions.</p>
<p>Both functions take the same arguments because they do the same thing, just with different schemas. First, they both take a string request body, which is NOT the query the user wrote! Rather, that should be the stringified JSON body that contains fields for the <code>query</code>, <code>variables</code>, etc. If you make that mistake, you'll get some very strange errors about schema validity no matter what you do!</p>
<p>The second argument is an <code>Option</code> of a string authentication header, which should be the raw value extracted from the HTTP <code>Authorization</code> header (which is where JWTs will be given). Do NOT try to pre-parse this in any way, even resolving it to a string, that will all be handled internally.</p>
<p>The third and final argument is an optional authentication verdict, which can be given to force the handling process to not run any authentication checks on the given token, but rather to use a predetermined verdict. This allows the use of authentication middleware to arrive at a verdict before all the HTTP data has been streamed in (more efficient). You can learn more about this <a href="core/./auth.html">here</a>. If you're not using middleware (not recommended unless you really can't), you should provide <code>None</code> here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-2"><a class="header" href="#authentication-2">Authentication</a></h1>
<p>If you're not using any middleware, you can entirely ignore this page and get on with building your custom system, but if you want to authenticate users more efficiently, this is for you.</p>
<p><code>DianaHandler</code> has the function <code>.is_authed()</code> that you can call in middleware, parsing in a raw authentication header just as you would if you were <a href="core/./queries_mutations.html">handling queries and mutations</a> without middleware. That will return an <a href="https://docs.rs/diana/0.2.3/diana/enum.AuthVerdict.html"><code>AuthVerdict</code></a>, which tells you if the client is allowed, blocked, or if an error occurred. Typically, you would continue the request on <code>Allow</code>, return a 403 on <code>Block</code>, and return a 500 on <code>Error</code> (though this could be caused by a bad request, it occurs in the context of the server). In future, a distinction may be made between server and client caused errors, which would allow reasonable returning of a 400 in some cases, but that's not yet implemented.</p>
<p>After you have an <code>AuthVerdict</code>, you can send that to your final handler in some way (Actix Web uses request extensions) and then extract it there to provide to <code>run_stateless_without_subscriptions()</code> or <code>.run_stateless_for_subscriptions</code>. If you do that, you don't need to provide the raw authentication header, as it won't be used, but you still can.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
